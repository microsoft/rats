from typing_extensions import NotRequired
from abc import abstractmethod
from collections.abc import Callable, Mapping, Sequence
from typing import Any, ParamSpec, Protocol, TypeVar, cast, TypedDict
import functools
from rats import apps


_CONFIGURATION_ANNOTATION_KEY = "__rats_config__"
FACTORY_SERVICE_ID_KEY = "_factory_service_id_"
ARGS_KEY = "_args_"
KWARGS_KEY = "_kwargs_"


class FactoryConfiguration(TypedDict):
    _factory_service_id_: str
    _args_: NotRequired[Sequence["Configuration"]]
    _kwargs_: NotRequired[Mapping[str, "Configuration"]]


Configuration = (
    int
    | str
    | float
    | bool
    | Sequence["Configuration"]
    | Mapping[str, "Configuration"]
    | FactoryConfiguration
)


class IObjectWithConfigurationAnnotation(Protocol):
    @property
    def __rats_config__(self) -> Configuration: ...


ConfiguredObject = (
    int
    | str
    | float
    | bool
    | Sequence["ConfiguredObject"]
    | Mapping[str, "ConfiguredObject"]
    | IObjectWithConfigurationAnnotation
)


def _has_configuration_annotation(obj: Any) -> bool:
    return hasattr(obj, _CONFIGURATION_ANNOTATION_KEY)


def _get_configuration_from_annotation(obj: IObjectWithConfigurationAnnotation) -> Configuration:
    return getattr(obj, _CONFIGURATION_ANNOTATION_KEY)


def _set_configuration_as_annotation(
    obj: Any, configuration: Configuration
) -> IObjectWithConfigurationAnnotation:
    setattr(obj, _CONFIGURATION_ANNOTATION_KEY, configuration)
    return obj


class IGetConfigurationFromObject(Protocol):
    @abstractmethod
    def __call__(self, obj: ConfiguredObject) -> Configuration:
        """Gets the a configuration that can recreate the object.

        Note that the configuration represents the object in its initial constructed state.
        If the object is stateful, the recreated object will not have the same state as the given
        object.
        """


class GetConfigurationFromObject:
    def _get_configuration_of_list(self, obj: Sequence[ConfiguredObject]) -> Configuration:
        return tuple(self(x) for x in obj)

    def _get_configuration_of_dict(self, obj: Mapping[str, ConfiguredObject]) -> Configuration:
        return {key: self(value) for key, value in obj.items()}

    def __call__(self, obj: ConfiguredObject) -> Configuration:
        """Gets the a configuration that can recreate the object.

        Note that the configuration represents the object in its initial constructed state.
        If the object is stateful, the recreated object will not have the same state as the given
        object.
        """
        if _has_configuration_annotation(obj):
            return _get_configuration_from_annotation(
                cast(IObjectWithConfigurationAnnotation, obj)
            )
        elif isinstance(obj, int):
            return obj
        elif isinstance(obj, str):
            return obj
        elif isinstance(obj, float):
            return obj
        elif isinstance(obj, bool):
            return obj
        elif isinstance(obj, Sequence):
            return self._get_configuration_of_list(obj)
        elif isinstance(obj, Mapping):
            return self._get_configuration_of_dict(obj)
        else:
            raise ValueError(f"Unsupported object type: {type(obj)}")


P = ParamSpec("P")
T_Container = TypeVar("T_Container", bound=apps.Container)
T = TypeVar("T")


class IFactoryToFactoryWithConfig(Protocol):
    @abstractmethod
    def __call__(
        self, service_id: apps.ServiceId[Callable[P, T]], factory: Callable[P, T]
    ) -> Callable[P, T]:
        """Adds configuration capabilities to factories.

        Wraps a factory function so that the generated object is a ConfiguredObject, i.e. carries
        information that allows extracting its configuration.  That configuration can be used to
        recreate the object.

        Assumes the factory is a service that can be retrieved from a container using the given
        service id.
        Assumes that the parameters to the wrapped factory are ConfiguredObjects, e.g. if they
        were generated by another factory with configuration capabilities.

        Args:
            service_id: The service id of the factory.
            factory: The factory function to wrap.
        """


class FactoryToFactoryWithConfig:
    _get_configuration_from_object: IGetConfigurationFromObject

    def __init__(self, get_configuration_from_object: IGetConfigurationFromObject) -> None:
        self._get_configuration_from_object = get_configuration_from_object

    def _cast_as_configured_object(self, obj: Any) -> ConfiguredObject:
        return obj

    def _get_configuration(self, obj: Any) -> Configuration:
        return self._get_configuration_from_object(self._cast_as_configured_object(obj))

    def _get_args_configuration(self, args: Sequence[Any]) -> Sequence[Configuration]:
        return tuple(self._get_configuration(x) for x in args)

    def _get_kwargs_configuration(self, kwargs: Mapping[str, Any]) -> Mapping[str, Configuration]:
        return {key: self._get_configuration(value) for key, value in kwargs.items()}

    def __call__(
        self, service_id: apps.ServiceId[Callable[P, T]], factory: Callable[P, T]
    ) -> Callable[P, T]:
        """Adds configuration capabilities to factories.

        Wraps a factory function so that the generated object is a ConfiguredObject, i.e. carries
        information that allows extracting its configuration.  That configuration can be used to
        recreate the object.

        Assumes the factory is a service that can be retrieved from a container using the given
        service id.
        Assumes that the parameters to the wrapped factory are ConfiguredObjects, e.g. if they
        were generated by another factory with configuration capabilities.

        Args:
            service_id: The service id of the factory.
            factory: The factory function to wrap.
        """

        @functools.wraps(factory)
        def factory_with_config(*args: P.args, **kwargs: P.kwargs) -> T:
            configuration: FactoryConfiguration = {
                FACTORY_SERVICE_ID_KEY: service_id.name,
            }
            if len(args) > 0:
                configuration[ARGS_KEY] = self._get_args_configuration(args)
            if len(kwargs) > 0:
                configuration[KWARGS_KEY] = self._get_kwargs_configuration(kwargs)
            obj = factory(*args, **kwargs)
            _set_configuration_as_annotation(obj, configuration)
            return obj

        return factory_with_config


class IConfigurationToObject(Protocol):
    @abstractmethod
    def __call__(self, configuration: Configuration) -> ConfiguredObject:
        """Creates an object from a configuration."""


class ConfigurationToObject:
    _container: apps.Container

    def __init__(self, container: apps.Container) -> None:
        self._container = container

    def __call__(self, configuration: Configuration) -> ConfiguredObject:
        """Creates an object from a configuration."""
        if isinstance(configuration, Mapping):
            if "_factory_service_id_" in configuration:
                factory_configuration = cast(FactoryConfiguration, configuration)
                service_id = apps.ServiceId[Any](factory_configuration["_factory_service_id_"])
                factory = self._container.get(service_id)
                args = [self(x) for x in factory_configuration.get("_args_", tuple())]
                kwargs = {
                    key: self(value)
                    for key, value in factory_configuration.get("_kwargs_", {}).items()
                }
                return factory(*args, **kwargs)
            else:
                return {key: self(value) for key, value in configuration.items()}
        elif isinstance(configuration, int):
            return configuration
        elif isinstance(configuration, str):
            return configuration
        elif isinstance(configuration, float):
            return configuration
        elif isinstance(configuration, bool):
            return configuration
        elif isinstance(configuration, Sequence):
            return tuple(self(x) for x in configuration)
        else:
            raise ValueError(f"Unsupported configuration type: {type(configuration)}")
